{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/chord.js","webpack:///./src/legend.js","webpack:///./src/main.js","webpack:///./src/rect.js","webpack:///./src/stats.js","webpack:///./src/text.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;ACnEA;;AAEA;AACA;AACA;;AAEA,6D;;;;;;;;;;;;ACNA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;ACnBA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACzFA;AAAA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,qCAAqC,wCAAwC;AAC7E,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,iDAAiD,+CAA+C;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB,EAAE;AACtD,kCAAkC,YAAY;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;ACtGA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA,8BAA8B,oBAAoB,EAAE;AACpD,yEAAyE;;AAEzE;AACA,oHAAsE,gBAAgB,EAAE;AACxF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,gCAAgC,EAAE;AACtE,yCAAyC,gCAAgC,EAAE;AAC3E;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gCAAgC,EAAE;AAC3F;;AAEA;AACA,C;;;;;;;;;;;;;;ACnGA;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,YAAY,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,E;;;;;;;;;;;;;;AClBA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B,EAAE;;AAE1D;AACA","file":"hc5.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","import h5c from './src/main';\n\nvar root = typeof self == 'object' && self.self === self && self ||\n           typeof global == 'object' && global.global === global && global ||\n           this;\n\nroot.h5c = h5c;","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","export default function Chord(arg) {\n    var options = arg || {},\n        container = options.container || \"body\",\n        data = options.data,\n        vmap = options.vmap,\n        width = options.width || 800,\n        height = options.height || width,\n        radius = options.radius || Math.min(width/2, height/2),\n        padding = options.padding || 0.1,\n        colorDomain = options.colorDomain || null,\n        colors = options.colors || ['steelblue', 'red'],\n        hover = options.hover || function(d) {};\n\n    if(!vmap.hasOwnProperty(\"size\"))\n        vmap.size = 'count';\n\n    var matrix = data.map(function(rows){\n        return rows.map(function(row){\n            return row[vmap.size];\n        });\n    });\n\n    var chord = d3.layout.chord()\n        .padding( 0.1)\n        .sortSubgroups(d3.descending)\n        .matrix(matrix);\n\n    var colorValues = [];\n\n    data.forEach(function(rows){\n        rows.forEach(function(row){\n            colorValues = colorValues.concat(row[vmap.color]);\n        });\n    });\n\n    if(colorDomain === null) {\n        colorDomain = [Math.min.apply(null, colorValues), Math.max.apply(null, colorValues)];\n    }\n\n    var colorScale;\n\n    if(typeof colors == 'function') {\n        colorScale = colors;\n    } else {\n        colorScale = d3.scale.linear()\n            .domain([colorDomain[0], colorDomain[1]])\n            .range(colors);\n    }\n\n    var svg;\n    if(typeof container.append === 'function') {\n        svg = container;\n    } else {\n        var offset = Math.min((width / 2), (height / 2))\n        svg = d3.select(container).append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height)\n            .append(\"g\")\n                .attr(\"transform\", \"translate(\" + offset + \",\" + offset + \")\");\n    }\n\n    var core = svg.append(\"g\")\n        .attr(\"class\", \"chord\")\n        .selectAll(\"path\")\n        .data(chord.chords)\n        .enter();\n\n    var ribbons = core.append(\"path\").attr(\"class\", \"ribbons\")\n        .attr(\"d\", d3.svg.chord().radius(radius))\n        .style(\"fill\", function(d){\n            var send = data[d.source.index][d.target.index][vmap.color];\n            var recv =  data[d.target.index][d.source.index][vmap.color];\n            return colorScale(Math.max(send, recv));\n        })\n        .style(\"stroke\", \"#FFF\")\n        .style(\"opacity\", 1);\n\n    chord.svg = svg;\n    chord.colorDomain = colorDomain;\n    chord.updateColor = function(colorDomain) {\n        chord.colorDomain = colorDomain;\n        colorScale.domain(colorDomain);\n        d3.selectAll('.ribbons').style(\"fill\", function(d){\n            var send = data[d.source.index][d.target.index][vmap.color];\n            var recv =  data[d.target.index][d.source.index][vmap.color];\n            return colorScale(Math.max(send, recv));\n        })\n    }\n    return chord;\n}\n\n","var gradID = 0;\nexport default function colorLegend(arg){\n    var option = arg || {},\n        container = option.container || null,\n        width = option.width || 200,\n        height = option.height || 20,\n        pos = option.pos ||[0, 0],\n        padding = option.padding || {left: 15, right: 15, top: 20, bottom: 0},\n        vmap = option.vmap || {},\n        noLabel = option.nolabel || false,\n        colors = option.colors || ['#eee', 'steelblue'],\n        domain = option.domain || ['min', 'max'],\n        format = option.format || d3.format(\".2s\");\n\n    var gradientID = gradID++;\n\n    width -= padding.left + padding.right;\n    height -= padding.top + padding.bottom;\n\n    var legend = (container === null) ? new Svg({width: width, height: height, padding: padding}) : container.svg,\n        rect = legend.append(\"g\");\n\n    if(container !== null){\n        if(typeof container.append === 'function')\n            container.append(legend);\n        else if(typeof container.appendChild === 'function')\n            container.appendChild(legend);\n        else if(typeof container === 'string')\n            document.getElementById(container).appendChild(legend);\n    }\n\n    function linearDomain(domain, n){\n        var step = (domain[1] - domain[0])/(n),\n            res = [];\n        for(var i = domain[0]; i<=domain[1]; i+=step) {\n            res.push(i);\n        }\n\n        res.push(domain[1]);\n        return res;\n    }\n\n    var colorScale = d3.scale.linear().domain(linearDomain([0, colors.length], colors.length)).range(colors);\n\n    function linearGradient(colors) {\n        var gradient = legend.append(\"defs\")\n            .append(\"linearGradient\")\n                .attr(\"id\", \"gradlegend\"+gradientID)\n                .attr(\"x1\", \"0%\")\n                .attr(\"x2\", \"100%\")\n                .attr(\"y1\", \"0%\")\n                .attr(\"y2\", \"0%\");\n\n        colors.forEach(function(c, i){\n            gradient.append(\"stop\")\n                .attr(\"offset\", i / colors.length )\n                .attr(\"stop-color\", c);\n        });\n        return gradient;\n    }\n\n    var grad = linearGradient(colors);\n\n    var rect = legend.append(\"g\");\n\n    var colorScale = rect.append(\"rect\")\n        .attr(\"x\", pos[0])\n        .attr(\"y\", pos[1])\n        .attr(\"width\", width-padding.left)\n        .attr(\"height\", height)\n        .style(\"fill\",\"url(#gradlegend\" + gradientID + \")\");\n\n    if(!noLabel) {\n        legend.append(\"text\")\n            .attr(\"x\", pos[0] - 5)\n            .attr(\"y\", pos[1] + height/2 + 5)\n            .style(\"fill\", \"#222\")\n            .style(\"text-anchor\", 'end')\n            // .style(\"font-size\", \".9em\")\n            .text(format(domain[0]));\n\n        legend.append(\"text\")\n            .attr(\"x\", pos[0] + width - padding.left + 5)\n            .attr(\"y\", pos[1] + height/2 + 5)\n            .style(\"fill\", \"#222\")\n            .style(\"text-anchor\", 'begin')\n            // .style(\"font-size\", \".9em\")\n            .text(format(domain[1]));\n    }\n\n\n    if(option.title) {\n        legend.append(\"g\")\n            .append(\"text\")\n            .attr(\"y\", pos[1] - padding.top)\n            .attr(\"x\", pos[0] + width/2)\n            .attr(\"dy\", \"1em\")\n            .style(\"text-anchor\", \"middle\")\n            .text(option.title);\n    }\n\n    return legend;\n}\n\n","import chord  from './chord';\nimport textLabel  from './text';\nimport rect   from './rect';\nimport legend from './legend';\n\nexport default function hc5(spec) {\n    let layers = spec.layers;\n    let rings = new Array(layers.length);\n\n    var config = spec.config,\n        width = config.width || 800,\n        height = config.height || width,\n        padding = config.padding || 10,\n        outerRadius = config.outerRadius || Math.min(width/2, height/2),\n        innerRadius = config.innerRadius || Math.min(width/4, height/4),\n        container = config.container || \"body\",\n        parentRing = container,\n        chartTitle = config.chartTitle || false,\n        colorDomains = config.colorDomains || [];\n\n    outerRadius -= padding;\n\n    var cirRange = outerRadius - innerRadius - padding,\n        cirOffset = innerRadius,\n        sectionRadius = cirOffset,\n        cirSize = layers\n            .map(function(layer){ return layer.size; })\n            .reduce(function(a,b){return a+b;});\n\n    layers.forEach(function(layer, li){\n        var sectionRadiusRange =  cirOffset + layer.size / cirSize * cirRange,\n            cirPadding = 0.05 * sectionRadiusRange,\n            sectionRadius = sectionRadiusRange,\n            colorDomain = ['min', 'max'];\n\n        if(layer.type == 'link') {\n            rings[li] = chord({\n                container: container,\n                data: layer.data,\n                width: width,\n                height: height,\n                colors: layer.colors,\n                radius: cirOffset,\n                colorDomain: colorDomains[li],\n                vmap: layer.vmap,\n            });\n            parentRing = rings[li];\n            container = rings[li];\n        }\n        else if(layer.type == 'bar') {\n            rings[li] = rect({\n                container: container,\n                data: layer.data,\n                innerRadius: cirOffset,\n                outerRadius: sectionRadius,\n                colors: layer.colors,\n                colorDomain: colorDomains[li],\n                vmap: layer.vmap || layer.encoding,\n            });\n            cirOffset = sectionRadius + cirPadding;\n        } else if(layer.type == 'text') {\n            layer.container = container;\n            layer.radius = cirOffset;\n            rings[li] = textLabel(s);\n            cirOffset = sectionRadius + cirPadding ;\n        }\n\n        if(layer.type !== 'text' && layer.vmap) {\n            if(layer.legend) {\n                if(rings[li].colorDomain) colorDomain = rings[li].colorDomain;\n                legend({\n                    container: container,\n                    colors: layer.colors,\n                    height: Math.min(50, outerRadius/2 / layerlayer.length) ,\n                    width: width/2 - outerRadius / 2 - padding * 4,\n                    title: layer.project + ' (' + ((layer.vmap) ? layer.vmap.color : null) + ')',\n                    domain: colorDomain,\n                    pos: [outerRadius/2 + padding*4, padding*2 + outerRadius/2 + outerRadius/2 / (layerlayer.length-1) * si]\n                })\n            }\n        }\n\n        if(typeof container.svg.append == 'function' && chartTitle) {\n            container.svg.append(\"text\")\n                .style(\"font-size\", \"1.1em\")\n                .style(\"text-anchor\", \"middle\")\n                .attr(\"x\", 0)\n                .attr(\"y\", height/2 - 15)\n                .text(function(d, i) { return  chartTitle });\n        }\n    })\n\n    rings.updateColor = function(colorDomains) {\n        rings.forEach(function(ring, ri){\n\n            if(layers[ri].type !== 'text') {\n\n                ring.updateColor(colorDomains[ri]);\n            }\n        })\n    }\n    return rings;\n}\n\n","import getStats from './stats';\n\nexport default function bars(arg) {\n    var options = arg || {},\n        container = options.container || \"body\",\n        data = options.data,\n        vmap = options.vmap,\n        width = options.width || 800,\n        height = options.height || width,\n        outerRadius = options.outerRadius || Math.min(width/2, height/2),\n        innerRadius = options.innerRadius || outerRadius / 4,\n        padding = options.padding || 0.05,\n        domain = options.domain || null,\n        colorDomain = options.colorDomain || null,\n        stats = options.stats || null,\n        colors = options.colors || ['white', 'steelblue'],\n        hover = options.hover || function(d) {};\n\n    var chords = container.groups();\n    var dataItems = [];\n    chords.forEach(function(chord, ci){\n        var delta = (chord.endAngle - chord.startAngle ) / data[ci].length;\n        data[ci].forEach(function(d, di){\n            var start =  chord.startAngle + di*delta;\n            d.startAngle = start;\n            d.endAngle = start + delta;\n            d.index = chord.index;\n        })\n        dataItems = dataItems.concat(data[ci]);\n    })\n\n    var svg = container.svg;\n\n    var bars = svg.append(\"g\")\n        .attr(\"transform\", \"translate(\" + (width / 2) + \",\" + (height / 2) + \")\");\n\n    var getSize = function() { return outerRadius; },\n        getColor = (typeof colors === 'function') ? colors : function() { return colors[0]};\n\n    if(stats === null) {\n        stats = getStats(dataItems, Object.keys(vmap).map(function(k){ return vmap[k]; }));\n    }\n\n    if(vmap.color && typeof(colors) != 'function') {\n\n        if(colorDomain === null) {\n            if(stats[vmap.color].max == stats[vmap.color].min) stats[vmap.color].max+=0.000001;\n            colorDomain = [stats[vmap.color].min, stats[vmap.color].max];\n        }\n\n        if(typeof colors == 'function') {\n            getColor = colors;\n        } else {\n            getColor =  d3.scale.linear()\n                .domain(colorDomain)\n                .range(colors);\n        }\n    }\n\n    if(vmap.size) {\n        getSize =  d3.scale.pow().exponent(0.9)\n            .domain([stats[vmap.size].min, stats[vmap.size].max])\n            .range([innerRadius, outerRadius]);\n    }\n\n    function createArc(d) {\n        return d3.svg.arc()\n            .innerRadius(innerRadius)\n            .outerRadius(getSize(d[vmap.size]))\n            (d);\n    }\n\n    var ring = svg.append(\"g\").selectAll(\".bar\")\n\n        .data(dataItems)\n        .enter()\n\n    var marks = ring.append(\"path\").attr(\"class\", \"bars\")\n        .attr('class', 'bars')\n        .style(\"fill\", function(d) { return getColor(d[vmap.color]); })\n        // .style(\"stroke\", function(d) { return getColor(d[vmap.color]); })\n        .style(\"stroke\", '#fff')\n        .style(\"stroke-width\", 0.5)\n        // .style(\"fill-opacity\", function(d){return getOpacity(d[opacityAttr])})\n        .attr(\"d\", createArc)\n        // .on(\"mouseover\", highlight)\n        // .on(\"mouseout\", unhighlight);\n    // visualElement\n    //     .style(\"stroke\", '#fff')\n    //     .style(\"stroke-width\", 0.5);\n    bars.svg = svg;\n    bars.colorDomain = colorDomain;\n    bars.updateColor = function(colorDomain) {\n        bars.colorDomain = colorDomain;\n        getColor.domain(colorDomain);\n        d3.selectAll(\".bars\").style(\"fill\", function(d) { return getColor(d[vmap.color]); })\n    }\n\n    return bars;\n}","export default function stats(data, fields){\n\n    if(!Array.isArray(data))\n        throw new Error(\"Inproper input data format.\");\n\n    var result = {};\n\n    fields.forEach(function(f) {\n        var a = data.map(function(d){return d[f]; });\n        result[f] = {\n            min: array.min(a),\n            max: array.max(a),\n            avg: array.avg(a),\n            std: array.std(a)\n        };\n    });\n\n    return result;\n};","export default function Text(arg) {\n    var options = arg || {},\n        container = options.container || \"body\",\n        data = options.data,\n        prefix = options.prefix || '',\n        radius = options.radius || 200,\n        color = options.color || '#000000',\n        hover = options.hover || function(d) {};\n\n    var chords = container.groups();\n    // chords.forEach(function(chord, ci){\n    //\n    //     data[ci].startAngle = chord.startAngle\n    //     data[ci].endAngle = chord.endAngle;\n    //     data[ci].index = chord.index;\n    // })\n\n    function textTransofrm(d) {\n        var offset = (d.startAngle + (d.endAngle - d.startAngle)/2);\n        return (offset > Math.PI/2 && offset < 1.5*Math.PI) ? \"rotate(270)\" :\"rotate(90)\";\n    }\n\n    function textRotate(d) {\n        var offset = (d.startAngle + (d.endAngle - d.startAngle)/2);\n        return \"rotate(\" + ( offset * 180 / Math.PI - 90)\n            + \")translate(\" + (radius+5) + \",0)\";\n    }\n\n    var groupLabel = container.svg.append(\"g\").selectAll(\"groupLabel\")\n            .data(chords)\n            .enter().append(\"g\")\n            .attr(\"transform\", textRotate);\n\n    groupLabel.append(\"text\")\n        .style(\"font-size\", \"0.9em\")\n        .style(\"text-anchor\", \"middle\")\n        .attr(\"dy\", \".35em\")\n        .attr(\"transform\",  textTransofrm)\n        .text(function(d, i) { return  prefix + data[i]; });\n\n    return groupLabel;\n}\n\n"],"sourceRoot":""}